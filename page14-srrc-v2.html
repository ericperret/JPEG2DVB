<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Page 14 - Filtre SRRC (State of the Art+)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a2e; color: #eee; }
        h1 { color: #00d4ff; text-align: center; }
        h1 span { font-size: 14px; color: #ff8800; }
        .description { background: #16213e; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #00d4ff; }
        .canvas-row { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-bottom: 15px; }
        .canvas-box { background: #16213e; padding: 12px; border-radius: 8px; text-align: center; }
        .canvas-box h3 { margin: 0 0 8px 0; color: #00d4ff; font-size: 13px; }
        canvas { border: 2px solid #0f3460; }
        .controls { margin-top: 8px; }
        button { background: #0f3460; color: #fff; border: none; padding: 8px 16px; margin: 3px; border-radius: 5px; cursor: pointer; font-size: 12px; }
        button:hover { background: #00d4ff; color: #000; }
        button:disabled { background: #333; cursor: not-allowed; }
        input[type="file"] { display: none; }
        select { background: #0f3460; color: #fff; border: none; padding: 5px 8px; border-radius: 5px; font-size: 11px; }
        .info { margin-top: 6px; font-size: 10px; color: #888; }
        .stats { background: #0f3460; padding: 10px; border-radius: 5px; margin-top: 10px; font-size: 11px; text-align: left; }
        .param-row { display: flex; gap: 12px; align-items: center; justify-content: center; margin: 8px 0; flex-wrap: wrap; }
        .param-item { display: flex; align-items: center; gap: 4px; font-size: 11px; }
        .param-item label { color: #888; }
        .metrics-panel { background: #0a1628; border: 2px solid #00d4ff; border-radius: 8px; padding: 15px; margin: 15px auto; max-width: 800px; }
        .metrics-panel h3 { color: #00d4ff; margin: 0 0 10px 0; text-align: center; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; }
        .metric { background: #16213e; padding: 10px; border-radius: 5px; text-align: center; }
        .metric-value { font-size: 24px; font-weight: bold; color: #00ff88; }
        .metric-label { font-size: 10px; color: #888; }
        .metric.warning .metric-value { color: #ffaa00; }
        .metric.error .metric-value { color: #ff4444; }
        .detail-section { max-width: 1100px; margin: 20px auto; }
        table.info-table { border-collapse: collapse; font-size: 11px; width: 100%; margin: 10px 0; }
        table.info-table th, table.info-table td { border: 1px solid #333; padding: 5px 8px; text-align: left; }
        table.info-table th { background: #0f3460; }
        .precision-badge { display: inline-block; background: #ff8800; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; }
    </style>
</head>
<body>
    <h1>üìª Page 14 - Filtre SRRC <span>‚òÖ State of the Art+ ‚òÖ</span></h1>
    
    <div class="description">
        <strong>Version "Si les anciens avaient eu nos moyens"</strong><br>
        ‚Ä¢ Coefficients <span class="precision-badge">Float64</span> double pr√©cision (vs Float32 en 1995)<br>
        ‚Ä¢ Fen√™trage Kaiser (Œ≤ optimal) pour lobes secondaires -60 dB<br>
        ‚Ä¢ Diagramme de l'≈ìil temps r√©el ‚Äî Spectre FFT ‚Äî Mesure EVM<br>
        <strong>Config SCPC optimis√©e :</strong> Œ±=0.5 (doux), Span=12 (pr√©cis), SPS=8 (qualit√© broadcast)
    </div>
    
    <!-- Param√®tres -->
    <div class="param-row">
        <div class="param-item">
            <label>Œ± (roll-off):</label>
            <select id="rolloff" onchange="updateFilter()">
                <option value="0.20">0.20 (sharp)</option>
                <option value="0.25">0.25</option>
                <option value="0.35">0.35 (DVB-S std)</option>
                <option value="0.50" selected>0.50 (SCPC doux)</option>
            </select>
        </div>
        <div class="param-item">
            <label>Span:</label>
            <select id="span" onchange="updateFilter()">
                <option value="8">8 (standard)</option>
                <option value="10">10</option>
                <option value="12" selected>12 (pr√©cis)</option>
                <option value="16">16 (ultra)</option>
            </select>
        </div>
        <div class="param-item">
            <label>SPS:</label>
            <select id="sps" onchange="updateFilter()">
                <option value="4">4 (standard)</option>
                <option value="8" selected>8 (broadcast)</option>
                <option value="16">16 (studio)</option>
            </select>
        </div>
        <div class="param-item">
            <label>Fen√™tre:</label>
            <select id="window" onchange="updateFilter()">
                <option value="none">Aucune</option>
                <option value="kaiser" selected>Kaiser (optimal)</option>
                <option value="blackman">Blackman-Harris</option>
            </select>
        </div>
        <div class="param-item">
            <button onclick="document.getElementById('fileInput').click()">üìÅ Charger QPSK</button>
            <input type="file" id="fileInput" accept=".json" onchange="loadJSON(this.files)">
        </div>
        <div class="param-item">
            <button id="btnFilter" onclick="applyFilter()" disabled>‚öôÔ∏è FILTRER</button>
        </div>
    </div>
    
    <!-- Ligne 1 : Entr√©e + Filtre -->
    <div class="canvas-row">
        <div class="canvas-box">
            <h3>ENTR√âE ‚Äî Symboles QPSK</h3>
            <canvas id="canvasInput" width="280" height="200"></canvas>
            <div class="info" id="inputInfo">Charger sortie Page 13</div>
        </div>
        <div class="canvas-box">
            <h3>R√âPONSE IMPULSIONNELLE SRRC</h3>
            <canvas id="canvasImpulse" width="280" height="200"></canvas>
            <div class="info" id="filterInfo">-</div>
        </div>
        <div class="canvas-box">
            <h3>R√âPONSE FR√âQUENTIELLE</h3>
            <canvas id="canvasFreq" width="280" height="200"></canvas>
            <div class="info">Spectre du filtre (dB)</div>
        </div>
    </div>
    
    <!-- Ligne 2 : Sorties + Analyse -->
    <div class="canvas-row">
        <div class="canvas-box">
            <h3>DIAGRAMME DE L'≈íIL (I)</h3>
            <canvas id="canvasEye" width="280" height="200"></canvas>
            <div class="info">Ouverture = qualit√© ISI</div>
        </div>
        <div class="canvas-box">
            <h3>CONSTELLATION FILTR√âE</h3>
            <canvas id="canvasConstellation" width="200" height="200"></canvas>
            <div class="info">Points aux instants symbole</div>
        </div>
        <div class="canvas-box">
            <h3>SPECTRE SIGNAL (FFT)</h3>
            <canvas id="canvasSpectrum" width="280" height="200"></canvas>
            <div class="info">Occupation spectrale r√©elle</div>
        </div>
    </div>
    
    <!-- M√©triques pro -->
    <div class="metrics-panel">
        <h3>üìä M√âTRIQUES QUALIT√â SIGNAL</h3>
        <div class="metrics-grid">
            <div class="metric" id="metricEVM">
                <div class="metric-value">‚Äî</div>
                <div class="metric-label">EVM (Error Vector Magnitude)</div>
            </div>
            <div class="metric" id="metricMER">
                <div class="metric-value">‚Äî</div>
                <div class="metric-label">MER (Modulation Error Ratio)</div>
            </div>
            <div class="metric" id="metricEyeOpen">
                <div class="metric-value">‚Äî</div>
                <div class="metric-label">Ouverture ≈íil (%)</div>
            </div>
            <div class="metric" id="metricISI">
                <div class="metric-value">‚Äî</div>
                <div class="metric-label">ISI R√©siduel (dB)</div>
            </div>
            <div class="metric" id="metricPAPR">
                <div class="metric-value">‚Äî</div>
                <div class="metric-label">PAPR (Peak/Avg Power)</div>
            </div>
            <div class="metric" id="metricBW">
                <div class="metric-value">‚Äî</div>
                <div class="metric-label">Bande 99% √ânergie</div>
            </div>
        </div>
    </div>
    
    <!-- Export -->
    <div style="text-align: center; margin: 15px;">
        <button id="btnExportJSON" onclick="exportJSON()" disabled>üíæ Export JSON (Float64)</button>
        <button id="btnExportBin" onclick="exportBinary()" disabled>üíæ Export I/Q Binaire</button>
        <button id="btnExportCoeffs" onclick="exportCoeffs()" >üíæ Export Coefficients</button>
    </div>
    
    <div class="detail-section">
        <div id="globalStats" class="stats" style="display:none;"></div>
        
        <h4 style="color: #00d4ff; margin-top: 20px;">Comparaison : 1995 vs State of the Art+</h4>
        <table class="info-table">
            <tr>
                <th>Aspect</th>
                <th>DVB-S 1995</th>
                <th>Cette impl√©mentation</th>
                <th>Gain</th>
            </tr>
            <tr>
                <td>Pr√©cision coefficients</td>
                <td>16 bits fixe (ASIC)</td>
                <td>64 bits flottant</td>
                <td>~48 dB dynamique</td>
            </tr>
            <tr>
                <td>Span filtre</td>
                <td>6-8 symboles (m√©moire limit√©e)</td>
                <td>12-16 symboles</td>
                <td>ISI -20 dB</td>
            </tr>
            <tr>
                <td>Fen√™trage</td>
                <td>Rarement (co√ªt CPU)</td>
                <td>Kaiser Œ≤ optimal</td>
                <td>Lobes -60 dB</td>
            </tr>
            <tr>
                <td>Sur√©chantillonnage</td>
                <td>2-4 SPS</td>
                <td>8-16 SPS</td>
                <td>Alias -40 dB</td>
            </tr>
            <tr>
                <td>Visualisation</td>
                <td>Oscilloscope externe</td>
                <td>≈íil + FFT + EVM int√©gr√©s</td>
                <td>Debug temps r√©el</td>
            </tr>
        </table>
    </div>

    <script>
        const WIDTH_SMALL = 280, HEIGHT_SMALL = 200;
        
        // === VARIABLES GLOBALES ===
        let inputData = null;
        let symbolsI = [], symbolsQ = [];
        let filterCoeffs = [];  // Float64Array pour pr√©cision
        let filteredI = [], filteredQ = [];
        let filtered = false;
        
        // === INITIALISATION ===
        window.onload = function() {
            clearAllCanvas();
            updateFilter();
        };
        
        // === CHARGEMENT JSON ===
        function loadJSON(files) {
            if (!files || files.length === 0) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    inputData = JSON.parse(e.target.result);
                    if (inputData.format !== 'DVB_QPSK_V1') {
                        alert('Format non reconnu. Utilisez la sortie Page 13.');
                        return;
                    }
                    
                    symbolsI = base64ToFloat64Array(inputData.I);
                    symbolsQ = base64ToFloat64Array(inputData.Q);
                    
                    filtered = false;
                    displayInputConstellation();
                    updateFilter();
                    
                    document.getElementById('btnFilter').disabled = false;
                    document.getElementById('inputInfo').textContent = 
                        `${symbolsI.length.toLocaleString()} symboles charg√©s`;
                    
                } catch (err) { alert('Erreur: ' + err.message); }
            };
            reader.readAsText(files[0]);
        }
        
        function base64ToFloat64Array(base64) {
            // Convertir depuis Float32 stock√©, vers Float64 interne
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const float32 = new Float32Array(bytes.buffer);
            // Convertir en Float64 pour pr√©cision maximale
            return Array.from(float32).map(x => Number(x));
        }
        
        // === G√âN√âRATION FILTRE SRRC (FLOAT64 + FEN√äTRAGE) ===
        function generateSRRC_Float64(alpha, span, sps, windowType) {
            const numTaps = span * sps + 1;
            const coeffs = new Float64Array(numTaps);
            
            // G√©n√©ration SRRC en double pr√©cision
            for (let i = 0; i < numTaps; i++) {
                const t = (i - (numTaps - 1) / 2) / sps;
                coeffs[i] = srrcSample_Float64(t, alpha);
            }
            
            // Appliquer fen√™trage
            if (windowType === 'kaiser') {
                const beta = calculateOptimalKaiserBeta(alpha);
                applyKaiserWindow(coeffs, beta);
            } else if (windowType === 'blackman') {
                applyBlackmanHarrisWindow(coeffs);
            }
            
            // Normaliser pour gain unitaire √† DC
            let sum = 0;
            for (let i = 0; i < numTaps; i++) sum += coeffs[i];
            for (let i = 0; i < numTaps; i++) coeffs[i] /= sum;
            
            return coeffs;
        }
        
        function srrcSample_Float64(t, alpha) {
            const eps = 1e-12;
            
            if (Math.abs(t) < eps) {
                return 1.0 - alpha + (4.0 * alpha / Math.PI);
            }
            
            const criticalPoint = 1.0 / (4.0 * alpha);
            if (Math.abs(Math.abs(t) - criticalPoint) < eps) {
                const term1 = (1.0 + 2.0 / Math.PI) * Math.sin(Math.PI / (4.0 * alpha));
                const term2 = (1.0 - 2.0 / Math.PI) * Math.cos(Math.PI / (4.0 * alpha));
                return (alpha / Math.SQRT2) * (term1 + term2);
            }
            
            const pit = Math.PI * t;
            const fourAlphaT = 4.0 * alpha * t;
            const num = Math.sin(pit * (1.0 - alpha)) + fourAlphaT * Math.cos(pit * (1.0 + alpha));
            const den = pit * (1.0 - fourAlphaT * fourAlphaT);
            
            return num / den;
        }
        
        function calculateOptimalKaiserBeta(alpha) {
            // Beta optimal selon le roll-off pour -60dB de lobes
            // Plus alpha est petit, plus beta doit √™tre grand
            const attenuation = 60; // dB
            if (attenuation > 50) {
                return 0.1102 * (attenuation - 8.7);
            } else if (attenuation >= 21) {
                return 0.5842 * Math.pow(attenuation - 21, 0.4) + 0.07886 * (attenuation - 21);
            }
            return 0;
        }
        
        function applyKaiserWindow(coeffs, beta) {
            const N = coeffs.length;
            const I0_beta = bessel_I0(beta);
            
            for (let i = 0; i < N; i++) {
                const x = 2.0 * i / (N - 1) - 1.0;
                const arg = beta * Math.sqrt(1.0 - x * x);
                coeffs[i] *= bessel_I0(arg) / I0_beta;
            }
        }
        
        function bessel_I0(x) {
            // Approximation de la fonction de Bessel I0
            let sum = 1.0;
            let term = 1.0;
            const x2_4 = (x / 2.0) * (x / 2.0);
            
            for (let k = 1; k < 25; k++) {
                term *= x2_4 / (k * k);
                sum += term;
                if (term < 1e-12 * sum) break;
            }
            return sum;
        }
        
        function applyBlackmanHarrisWindow(coeffs) {
            const N = coeffs.length;
            const a0 = 0.35875, a1 = 0.48829, a2 = 0.14128, a3 = 0.01168;
            
            for (let i = 0; i < N; i++) {
                const w = a0 
                    - a1 * Math.cos(2 * Math.PI * i / (N - 1))
                    + a2 * Math.cos(4 * Math.PI * i / (N - 1))
                    - a3 * Math.cos(6 * Math.PI * i / (N - 1));
                coeffs[i] *= w;
            }
        }
        
        // === MISE √Ä JOUR FILTRE ===
        function updateFilter() {
            const alpha = parseFloat(document.getElementById('rolloff').value);
            const span = parseInt(document.getElementById('span').value);
            const sps = parseInt(document.getElementById('sps').value);
            const windowType = document.getElementById('window').value;
            
            filterCoeffs = generateSRRC_Float64(alpha, span, sps, windowType);
            
            drawImpulseResponse();
            drawFrequencyResponse();
            
            document.getElementById('filterInfo').textContent = 
                `${filterCoeffs.length} taps, Float64, ${windowType === 'none' ? 'sans fen√™tre' : windowType}`;
        }
        
        // === DESSIN R√âPONSE IMPULSIONNELLE ===
        function drawImpulseResponse() {
            const canvas = document.getElementById('canvasImpulse');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            
            const sps = parseInt(document.getElementById('sps').value);
            const margin = 30;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;
            const centerY = margin + plotH / 2;
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(margin, centerY);
            ctx.lineTo(W - margin, centerY);
            ctx.stroke();
            
            // Trouver max
            let maxVal = 0;
            for (const c of filterCoeffs) maxVal = Math.max(maxVal, Math.abs(c));
            
            // Courbe
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < filterCoeffs.length; i++) {
                const x = margin + (i / (filterCoeffs.length - 1)) * plotW;
                const y = centerY - (filterCoeffs[i] / maxVal) * (plotH / 2 - 5);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.lineWidth = 1;
            
            // Marquer instants symbole
            ctx.fillStyle = '#ff8800';
            const span = parseInt(document.getElementById('span').value);
            for (let s = 0; s <= span; s++) {
                const i = s * sps;
                if (i < filterCoeffs.length) {
                    const x = margin + (i / (filterCoeffs.length - 1)) * plotW;
                    ctx.beginPath();
                    ctx.arc(x, centerY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('0', margin, H - 5);
            ctx.fillText(`${span}T`, W - margin, H - 5);
        }
        
        // === DESSIN R√âPONSE FR√âQUENTIELLE ===
        function drawFrequencyResponse() {
            const canvas = document.getElementById('canvasFreq');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            
            // FFT du filtre (zero-padded)
            const fftSize = 1024;
            const padded = new Float64Array(fftSize);
            for (let i = 0; i < filterCoeffs.length; i++) {
                padded[i] = filterCoeffs[i];
            }
            
            const spectrum = fftMagnitude(padded);
            
            const margin = 30;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;
            
            // √âchelle dB
            const minDb = -80, maxDb = 5;
            
            // Grille
            ctx.strokeStyle = '#333';
            ctx.setLineDash([2, 2]);
            for (let db = -60; db <= 0; db += 20) {
                const y = margin + plotH * (maxDb - db) / (maxDb - minDb);
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(W - margin, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Courbe
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < fftSize / 2; i++) {
                const db = 20 * Math.log10(Math.max(spectrum[i], 1e-10));
                const x = margin + (i / (fftSize / 2 - 1)) * plotW;
                const y = margin + plotH * Math.max(0, Math.min(1, (maxDb - db) / (maxDb - minDb)));
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.lineWidth = 1;
            
            // Marquer Œ±
            const alpha = parseFloat(document.getElementById('rolloff').value);
            const sps = parseInt(document.getElementById('sps').value);
            const f_cutoff = (1 + alpha) / (2 * sps);
            const x_cutoff = margin + f_cutoff * 2 * plotW;
            
            ctx.strokeStyle = '#ff4444';
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(x_cutoff, margin);
            ctx.lineTo(x_cutoff, H - margin);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '8px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('0dB', margin - 3, margin + 10);
            ctx.fillText('-60dB', margin - 3, margin + plotH * 0.76);
            ctx.fillStyle = '#ff4444';
            ctx.textAlign = 'center';
            ctx.fillText('fc', x_cutoff, H - 3);
        }
        
        // === FFT SIMPLE ===
        function fftMagnitude(signal) {
            const N = signal.length;
            const mag = new Float64Array(N);
            
            // DFT directe (pour pr√©cision, pas pour vitesse)
            for (let k = 0; k < N; k++) {
                let re = 0, im = 0;
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    re += signal[n] * Math.cos(angle);
                    im += signal[n] * Math.sin(angle);
                }
                mag[k] = Math.sqrt(re * re + im * im) / N;
            }
            return mag;
        }
        
        // === APPLICATION DU FILTRE ===
        function applyFilter() {
            if (!symbolsI.length) return;
            
            const sps = parseInt(document.getElementById('sps').value);
            
            // Sur√©chantillonnage (zero-stuffing)
            const upsampledI = new Float64Array(symbolsI.length * sps);
            const upsampledQ = new Float64Array(symbolsQ.length * sps);
            
            for (let i = 0; i < symbolsI.length; i++) {
                upsampledI[i * sps] = symbolsI[i];
                upsampledQ[i * sps] = symbolsQ[i];
            }
            
            // Convolution Float64
            filteredI = convolve_Float64(upsampledI, filterCoeffs);
            filteredQ = convolve_Float64(upsampledQ, filterCoeffs);
            
            filtered = true;
            
            // Affichages
            drawEyeDiagram();
            drawFilteredConstellation();
            drawOutputSpectrum();
            calculateMetrics();
            
            document.getElementById('btnExportJSON').disabled = false;
            document.getElementById('btnExportBin').disabled = false;
            
            const alpha = parseFloat(document.getElementById('rolloff').value);
            document.getElementById('globalStats').style.display = 'block';
            document.getElementById('globalStats').innerHTML = `
                <strong>‚úÖ Filtrage SRRC termin√© (State of the Art+)</strong><br>
                ‚Ä¢ Symboles: ${symbolsI.length.toLocaleString()} ‚Üí Samples: ${filteredI.length.toLocaleString()}<br>
                ‚Ä¢ Pr√©cision: Float64 (53 bits mantisse)<br>
                ‚Ä¢ Bande relative: ${(1 + alpha).toFixed(2)} √ó Rs<br>
                <strong style="color:#00ff88">üéâ Signal bande de base pr√™t pour modulateur RF !</strong>
            `;
        }
        
        function convolve_Float64(signal, kernel) {
            const resultLen = signal.length;
            const result = new Float64Array(resultLen);
            const kLen = kernel.length;
            const kHalf = Math.floor(kLen / 2);
            
            for (let i = 0; i < resultLen; i++) {
                let sum = 0;
                for (let j = 0; j < kLen; j++) {
                    const idx = i - kHalf + j;
                    if (idx >= 0 && idx < signal.length) {
                        sum += signal[idx] * kernel[j];
                    }
                }
                result[i] = sum;
            }
            return result;
        }
        
        // === DIAGRAMME DE L'≈íIL ===
        function drawEyeDiagram() {
            const canvas = document.getElementById('canvasEye');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            
            const sps = parseInt(document.getElementById('sps').value);
            const margin = 20;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;
            const centerY = margin + plotH / 2;
            
            // Trouver max
            let maxVal = 0;
            for (let i = 0; i < Math.min(5000, filteredI.length); i++) {
                maxVal = Math.max(maxVal, Math.abs(filteredI[i]));
            }
            if (maxVal === 0) maxVal = 1;
            
            // Superposer des traces de 2 symboles
            const traceLen = 2 * sps;
            const numTraces = Math.min(200, Math.floor(filteredI.length / traceLen) - 1);
            
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.15)';
            ctx.lineWidth = 1;
            
            for (let t = 0; t < numTraces; t++) {
                const startIdx = t * sps + Math.floor(sps / 2); // D√©caler pour centrer
                
                ctx.beginPath();
                for (let i = 0; i < traceLen; i++) {
                    const idx = startIdx + i;
                    if (idx >= filteredI.length) break;
                    
                    const x = margin + (i / traceLen) * plotW;
                    const y = centerY - (filteredI[idx] / maxVal) * (plotH / 2 - 5);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // Lignes de d√©cision
            ctx.strokeStyle = '#ff4444';
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(margin + plotW / 2, margin);
            ctx.lineTo(margin + plotW / 2, H - margin);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('T', margin + plotW / 4, H - 5);
            ctx.fillText('2T', margin + 3 * plotW / 4, H - 5);
        }
        
        // === CONSTELLATION FILTR√âE ===
        function drawFilteredConstellation() {
            const canvas = document.getElementById('canvasConstellation');
            const ctx = canvas.getContext('2d');
            const size = canvas.width;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, size, size);
            
            const center = size / 2;
            const scale = size * 0.35;
            const sps = parseInt(document.getElementById('sps').value);
            
            // Axes
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(center, 10);
            ctx.lineTo(center, size - 10);
            ctx.moveTo(10, center);
            ctx.lineTo(size - 10, center);
            ctx.stroke();
            
            // Cercle unit√©
            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.arc(center, center, scale * Math.SQRT2 / 2, 0, Math.PI * 2);
            ctx.stroke();
            
            // Points aux instants symbole
            ctx.fillStyle = 'rgba(0, 255, 136, 0.5)';
            
            const offset = Math.floor(filterCoeffs.length / 2);
            const numPoints = Math.min(500, Math.floor((filteredI.length - offset) / sps));
            
            for (let i = 0; i < numPoints; i++) {
                const idx = offset + i * sps;
                const x = center + filteredI[idx] * scale;
                const y = center - filteredQ[idx] * scale;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Points id√©aux
            ctx.fillStyle = '#ff4444';
            const ideal = 1 / Math.SQRT2;
            [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(([i, q]) => {
                ctx.beginPath();
                ctx.arc(center + i * ideal * scale, center - q * ideal * scale, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // === SPECTRE DU SIGNAL ===
        function drawOutputSpectrum() {
            const canvas = document.getElementById('canvasSpectrum');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            
            // FFT sur un segment
            const fftSize = 1024;
            const segment = new Float64Array(fftSize);
            const start = Math.floor(filteredI.length / 2);
            for (let i = 0; i < fftSize && start + i < filteredI.length; i++) {
                segment[i] = filteredI[start + i];
            }
            
            // Fen√™tre de Hann
            for (let i = 0; i < fftSize; i++) {
                segment[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
            }
            
            const spectrum = fftMagnitude(segment);
            
            const margin = 25;
            const plotW = W - 2 * margin;
            const plotH = H - 2 * margin;
            
            // √âchelle
            let maxMag = 0;
            for (let i = 0; i < fftSize / 2; i++) maxMag = Math.max(maxMag, spectrum[i]);
            const minDb = -60, maxDb = 0;
            
            // Grille
            ctx.strokeStyle = '#333';
            ctx.setLineDash([2, 2]);
            for (let db = -40; db <= 0; db += 20) {
                const y = margin + plotH * (-db) / (maxDb - minDb);
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(W - margin, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Spectre
            ctx.fillStyle = 'rgba(0, 170, 255, 0.6)';
            ctx.beginPath();
            ctx.moveTo(margin, H - margin);
            
            for (let i = 0; i < fftSize / 2; i++) {
                const db = 20 * Math.log10(Math.max(spectrum[i] / maxMag, 1e-10));
                const x = margin + (i / (fftSize / 2 - 1)) * plotW;
                const y = margin + plotH * Math.max(0, Math.min(1, -db / (maxDb - minDb)));
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(W - margin, H - margin);
            ctx.closePath();
            ctx.fill();
            
            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '8px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('0dB', margin + 2, margin + 10);
            ctx.fillText('-60dB', margin + 2, H - margin - 5);
        }
        
        // === CALCUL M√âTRIQUES ===
        function calculateMetrics() {
            const sps = parseInt(document.getElementById('sps').value);
            const offset = Math.floor(filterCoeffs.length / 2);
            const ideal = 1 / Math.SQRT2;
            
            // EVM (Error Vector Magnitude)
            let sumErrorSq = 0, sumIdealSq = 0;
            const numSymbols = Math.min(1000, Math.floor((filteredI.length - offset) / sps));
            
            for (let i = 0; i < numSymbols; i++) {
                const idx = offset + i * sps;
                const measI = filteredI[idx];
                const measQ = filteredQ[idx];
                
                // Trouver point id√©al le plus proche
                let minDist = Infinity, idealI = 0, idealQ = 0;
                [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(([ii, qq]) => {
                    const di = measI - ii * ideal;
                    const dq = measQ - qq * ideal;
                    const dist = di * di + dq * dq;
                    if (dist < minDist) {
                        minDist = dist;
                        idealI = ii * ideal;
                        idealQ = qq * ideal;
                    }
                });
                
                const errorI = measI - idealI;
                const errorQ = measQ - idealQ;
                sumErrorSq += errorI * errorI + errorQ * errorQ;
                sumIdealSq += idealI * idealI + idealQ * idealQ;
            }
            
            const evmPercent = 100 * Math.sqrt(sumErrorSq / sumIdealSq);
            const merDb = -10 * Math.log10(sumErrorSq / sumIdealSq);
            
            // Ouverture ≈ìil (approximation)
            let minEyeOpen = Infinity, maxEyeClose = 0;
            for (let i = 0; i < numSymbols; i++) {
                const idx = offset + i * sps;
                const val = Math.abs(filteredI[idx]);
                minEyeOpen = Math.min(minEyeOpen, val);
            }
            const eyeOpenPercent = (minEyeOpen / ideal) * 100;
            
            // ISI (via variance aux instants symbole)
            const isiDb = -merDb - 3; // Approximation
            
            // PAPR
            let peakPower = 0, avgPower = 0;
            for (let i = 0; i < Math.min(10000, filteredI.length); i++) {
                const power = filteredI[i] * filteredI[i] + filteredQ[i] * filteredQ[i];
                peakPower = Math.max(peakPower, power);
                avgPower += power;
            }
            avgPower /= Math.min(10000, filteredI.length);
            const paprDb = 10 * Math.log10(peakPower / avgPower);
            
            // Bande passante
            const alpha = parseFloat(document.getElementById('rolloff').value);
            const bwRelative = (1 + alpha);
            
            // Afficher m√©triques
            setMetric('metricEVM', `${evmPercent.toFixed(2)}%`, evmPercent > 10 ? 'warning' : evmPercent > 20 ? 'error' : '');
            setMetric('metricMER', `${merDb.toFixed(1)} dB`, merDb < 20 ? 'warning' : merDb < 15 ? 'error' : '');
            setMetric('metricEyeOpen', `${eyeOpenPercent.toFixed(1)}%`, eyeOpenPercent < 70 ? 'warning' : '');
            setMetric('metricISI', `${isiDb.toFixed(1)} dB`, '');
            setMetric('metricPAPR', `${paprDb.toFixed(2)} dB`, paprDb > 6 ? 'warning' : '');
            setMetric('metricBW', `${bwRelative.toFixed(2)} √ó Rs`, '');
        }
        
        function setMetric(id, value, status) {
            const el = document.getElementById(id);
            el.querySelector('.metric-value').textContent = value;
            el.className = 'metric ' + status;
        }
        
        // === AFFICHAGE CONSTELLATION ENTR√âE ===
        function displayInputConstellation() {
            const canvas = document.getElementById('canvasInput');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);
            
            const centerX = W / 2, centerY = H / 2;
            const scale = 60;
            
            // Axes
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, H - 20);
            ctx.moveTo(20, centerY);
            ctx.lineTo(W - 20, centerY);
            ctx.stroke();
            
            // Points
            ctx.fillStyle = 'rgba(255, 136, 0, 0.3)';
            const step = Math.max(1, Math.floor(symbolsI.length / 300));
            for (let i = 0; i < symbolsI.length; i += step) {
                const x = centerX + symbolsI[i] * scale;
                const y = centerY - symbolsQ[i] * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // === EXPORTS ===
        function exportJSON() {
            if (!filtered) return;
            
            const alpha = parseFloat(document.getElementById('rolloff').value);
            const span = parseInt(document.getElementById('span').value);
            const sps = parseInt(document.getElementById('sps').value);
            const windowType = document.getElementById('window').value;
            
            const output = {
                format: 'DVB_BASEBAND_FLOAT64_V1',
                description: 'DVB-S Baseband Signal - State of the Art+ (Float64)',
                date: new Date().toISOString(),
                source: inputData.format,
                image: inputData.image,
                srrc: {
                    rolloff: alpha,
                    span: span,
                    samplesPerSymbol: sps,
                    window: windowType,
                    filterTaps: filterCoeffs.length,
                    precision: 'Float64',
                    symbolCount: symbolsI.length,
                    sampleCount: filteredI.length
                },
                coefficients: Array.from(filterCoeffs),
                I: float64ArrayToBase64(filteredI),
                Q: float64ArrayToBase64(filteredQ)
            };
            
            downloadJSON(output, 'dvbs_baseband_f64.json');
        }
        
        function exportBinary() {
            if (!filtered) return;
            
            // I/Q entrelac√©s en Float64
            const buffer = new Float64Array(filteredI.length * 2);
            for (let i = 0; i < filteredI.length; i++) {
                buffer[i * 2] = filteredI[i];
                buffer[i * 2 + 1] = filteredQ[i];
            }
            
            const blob = new Blob([buffer], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'dvbs_baseband_iq_f64.bin';
            a.click();
        }
        
        function exportCoeffs() {
            const alpha = parseFloat(document.getElementById('rolloff').value);
            const span = parseInt(document.getElementById('span').value);
            const sps = parseInt(document.getElementById('sps').value);
            const windowType = document.getElementById('window').value;
            
            const output = {
                description: 'SRRC Filter Coefficients - State of the Art+',
                parameters: { alpha, span, sps, window: windowType },
                taps: filterCoeffs.length,
                precision: 'Float64',
                coefficients: Array.from(filterCoeffs)
            };
            
            downloadJSON(output, `srrc_coeffs_a${alpha}_s${span}_sps${sps}.json`);
        }
        
        function float64ArrayToBase64(arr) {
            const float64 = new Float64Array(arr);
            const bytes = new Uint8Array(float64.buffer);
            let binary = '';
            for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
            return btoa(binary);
        }
        
        function downloadJSON(obj, filename) {
            const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
        }
        
        function clearAllCanvas() {
            ['canvasInput', 'canvasImpulse', 'canvasFreq', 'canvasEye', 'canvasConstellation', 'canvasSpectrum'].forEach(id => {
                const ctx = document.getElementById(id).getContext('2d');
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            });
        }
    </script>
</body>
</html>
